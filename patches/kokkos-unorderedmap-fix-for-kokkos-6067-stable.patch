From 661b089ccbfe7b2b59e21138e4cf29cf15f08fca Mon Sep 17 00:00:00 2001
From: "romin.tomasetti" <romin.tomasetti@gmail.com>
Date: Fri, 21 Apr 2023 09:04:58 +0000
Subject: [PATCH] kokkos(unorderedmap): fix for
 https://github.com/kokkos/kokkos/issues/6067

---
 .../containers/src/Kokkos_UnorderedMap.hpp    | 78 ++++++++++++++++---
 1 file changed, 66 insertions(+), 12 deletions(-)

diff --git a/packages/kokkos/containers/src/Kokkos_UnorderedMap.hpp b/packages/kokkos/containers/src/Kokkos_UnorderedMap.hpp
index 058b6626c40..4d4d0d48e5e 100644
--- a/packages/kokkos/containers/src/Kokkos_UnorderedMap.hpp
+++ b/packages/kokkos/containers/src/Kokkos_UnorderedMap.hpp
@@ -39,6 +39,24 @@
 
 #include <cstdint>
 
+namespace Kokkos::Impl
+{
+    //! Either append to the label if the property already exists, or set it.
+    template <typename... P>
+    auto with_updated_label(const ViewCtorProp<P...>& view_ctor_prop, const std::string& label)
+    {
+        //! If the label property is already set, append.
+        if constexpr (ViewCtorProp<P...>::has_label) {
+            auto new_ctor_props(view_ctor_prop);
+            static_cast<ViewCtorProp<void, std::string>&>(new_ctor_props).value.append(label);
+            return new_ctor_props;
+        //! Otherwise, set label.
+        } else {
+            return Impl::with_properties_if_unset(view_ctor_prop, label);
+        }
+    }
+} // namespace Kokkos::Impl
+
 namespace Kokkos {
 
 enum : unsigned { UnorderedMapInvalidIndex = ~0u };
@@ -272,28 +290,64 @@ class UnorderedMap {
   ///   default value usually suffices.
   UnorderedMap(size_type capacity_hint = 0, hasher_type hasher = hasher_type(),
                equal_to_type equal_to = equal_to_type())
+      : UnorderedMap(Kokkos::view_alloc(), capacity_hint, hasher, equal_to) {}
+
+  template <class... P>
+  UnorderedMap(const Impl::ViewCtorProp<P...>& arg_prop,
+               size_type capacity_hint = 0, hasher_type hasher = hasher_type(),
+               equal_to_type equal_to = equal_to_type())
       : m_bounded_insert(true),
         m_hasher(hasher),
         m_equal_to(equal_to),
         m_size(),
-        m_available_indexes(calculate_capacity(capacity_hint)),
-        m_hash_lists(view_alloc(WithoutInitializing, "UnorderedMap hash list"),
-                     Impl::find_hash_size(capacity())),
-        m_next_index(view_alloc(WithoutInitializing, "UnorderedMap next index"),
-                     capacity() + 1)  // +1 so that the *_at functions can
-                                      // always return a valid reference
-        ,
-        m_keys("UnorderedMap keys", capacity()),
-        m_values("UnorderedMap values", (is_set ? 0 : capacity())),
-        m_scalars("UnorderedMap scalars") {
+        m_available_indexes(calculate_capacity(capacity_hint))
+  {
     if (!is_insertable_map) {
       Kokkos::Impl::throw_runtime_exception(
           "Cannot construct a non-insertable (i.e. const key_type) "
           "unordered_map");
     }
 
-    Kokkos::deep_copy(m_hash_lists, invalid_index);
-    Kokkos::deep_copy(m_next_index, invalid_index);
+    //! Ensure that allocation properties are consistent.
+    using alloc_prop_t = std::decay_t<decltype(arg_prop)>;
+    static_assert(   alloc_prop_t::initialize , "Allocation property 'initialize' should be true.");
+    static_assert( ! alloc_prop_t::has_pointer, "Allocation properties should not contain the 'pointer' property.");
+
+    //! Update allocation properties with 'label' and 'without initializing' properties.
+    const auto prop_copy = Impl::with_properties_if_unset(arg_prop, std::string("UnorderedMap"));
+    const auto prop_copy_noinit = Impl::with_properties_if_unset(prop_copy, Kokkos::WithoutInitializing);
+
+    //! Initialize member views.
+    m_hash_lists = size_type_view(
+      Kokkos::Impl::with_updated_label(prop_copy_noinit, " - hash list"),
+      Impl::find_hash_size(capacity()));
+
+    m_next_index = size_type_view(
+      Kokkos::Impl::with_updated_label(prop_copy_noinit, " - next index"),
+      capacity() + 1);  // +1 so that the *_at functions can always return a valid reference
+
+    m_keys = key_type_view(
+      Kokkos::Impl::with_updated_label(prop_copy, " - keys"),
+      capacity());
+
+    m_values = value_type_view(
+      Kokkos::Impl::with_updated_label(prop_copy, " - values"),
+      is_set ? 0 : capacity());
+
+    m_scalars = scalars_view(
+      Kokkos::Impl::with_updated_label(prop_copy, " - scalars"));
+
+    /**
+     * Deep copies should also be done using the space instance if given. Instead of the if/else we could use the
+     * @c get_property_or_default, but giving even the default execution space instance will change the behavior of @c deep_copy.
+     */
+    if constexpr (alloc_prop_t::has_execution_space) {
+      Kokkos::deep_copy(Impl::get_property<Impl::ExecutionSpaceTag>(arg_prop), m_hash_lists, invalid_index);
+      Kokkos::deep_copy(Impl::get_property<Impl::ExecutionSpaceTag>(arg_prop), m_next_index, invalid_index);
+    } else {
+      Kokkos::deep_copy(m_hash_lists, invalid_index);
+      Kokkos::deep_copy(m_next_index, invalid_index);
+    }
   }
 
   void reset_failed_insert_flag() { reset_flag(failed_insert_idx); }
-- 
2.40.0

